#pragma kernel CSMainNew

struct Agent {
    float2 position;
    float2 direction;
};

int numOfAgents;
float deltaTime;
RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> ResultTexture; // use RWTexture2D for UAV access

float sdfCircle(float2 p, float r) {
    return length(p) - r;
}

[numthreads(8, 8, 1)]
void CSMainNew (uint3 id : SV_DispatchThreadID)
{
    // note: code used for understanding threads
    // if (id.x < 0) {
    //     ResultTexture[id.xy] = float4(1, 0, 0, 1);
    //     return;
    // }
    // if (id.x < 0 || id.x > dimensions.x || id.y < 0 || id.y > dimensions.y) {
    //     return;
    // }

    // note: here we reset the background color to black every time
    uint2 dimensions;
    ResultTexture.GetDimensions(dimensions.x, dimensions.y);

    // float radius = min(dimensions.x, dimensions.y) * 0.4;
    float radius = 0.02;
    float2 uv = float2(id.xy) / float2(dimensions);
    uv = 2.0 * (uv - 0.5);
    uv = uv * float2(dimensions) / 500;

    float3 red = float3(1.0, 0.0, 0.0);
    float3 black = float3(0.0, 0.0, 0.0);
    float3 color = black;

    for (int i = 0; i < numOfAgents; i++) {
        float2 pos = agents[i].position + 0.005 * agents[i].direction * deltaTime;

        if (pos.x < -1 || pos.x > 1) {
            agents[i].direction.x *= -1;
        }
        if (pos.y < -1 || pos.y > 1) {
            agents[i].direction.y *= -1;
        }

        float dist = sdfCircle(uv - pos, radius);

        // set position
        agents[i].position = pos;

        // float dist = sdfCircle(uv, radius);
        color = dist <= 0 ? red : color;
    }

    ResultTexture[id.xy] = float4(color, 1.0);
}