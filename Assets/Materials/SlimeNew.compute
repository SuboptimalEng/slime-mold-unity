#pragma kernel CSMainNew

struct Agent {
    float2 position;
    float2 direction;
};

int numOfAgents;
float deltaTime;
RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> ResultTexture; // use RWTexture2D for UAV access

float sdfCircle(float2 p, float r) {
    return length(p) - r;
}

[numthreads(8, 8, 1)]
void CSMainNew (uint3 id : SV_DispatchThreadID)
{
    // note: code used for understanding threads
    // if (id.x < 0) {
    //     ResultTexture[id.xy] = float4(1, 0, 0, 1);
    //     return;
    // }
    // if (id.x < 0 || id.x > dimensions.x || id.y < 0 || id.y > dimensions.y) {
    //     return;
    // }

    // note: here we reset the background color to black every time
    uint2 dimensions;
    ResultTexture.GetDimensions(dimensions.x, dimensions.y);

    // float radius = min(dimensions.x, dimensions.y) * 0.4;
    float radius = 0.02;
    float2 uv = float2(id.xy) / float2(dimensions);
    uv = 2.0 * (uv - 0.5);
    uv = uv * float2(dimensions) / 500;

    float3 white = float3(1.0, 1.0, 1.0);
    float3 black = float3(0.0, 0.0, 0.0);
    float3 color = black;

    for (int i = 0; i < numOfAgents; i++) {
        float2 pos = agents[i].position + 0.005 * agents[i].direction * deltaTime;

        if (pos.x < -1 || pos.x > 1) {
            agents[i].direction.x *= -1;
        }
        if (pos.y < -1 || pos.y > 1) {
            agents[i].direction.y *= -1;
        }

        float dist = sdfCircle(uv - pos, radius);

        // set position
        agents[i].position = pos;

        // float dist = sdfCircle(uv, radius);
        color = dist <= 0 ? white : color;
    }

    ResultTexture[id.xy] = float4(color, 1.0);
}

#pragma kernel CSTrailMap

// note: declaring this results in error because it was declared before
// RWTexture2D<float4> ResultTexture;
RWTexture2D<float4> TrailMapTexture;

[numthreads(8, 8, 1)]
void CSTrailMap(uint3 id : SV_DispatchThreadID)
{
    float4 trailMapColor = TrailMapTexture[id.xy];

    // todo: check if this is first undefined (looks like it's not)

    // note: doing this first makes more sense (kinda)
    // note: lower the trail map color slightly on each iteration
    // trailMapColor.x = trailMapColor.x - 0.01 < 0 ? 0 : trailMapColor.x - 0.01;
    trailMapColor = max(0, trailMapColor.x - 0.01);

    // note: if the resultTexture is set to 1, then set trailMapColor to 1 as well
    // trailMapColor.x = ResultTexture[id.xy].x > 0.99 ? 1 : trailMapColor.x;
    trailMapColor = max(ResultTexture[id.xy].x, trailMapColor.x);

    // set texture
    TrailMapTexture[id.xy] = trailMapColor;
}


// NOTE: DO THIS IN A SEPARATE PASS
#pragma kernel CSDiffuse
RWTexture2D<float4> DiffusedTrailMapTexture;
int width;
int height;

[numthreads(8, 8, 1)]
void CSDiffuse(uint3 id : SV_DispatchThreadID)
{
    // note: do not blur on the same map as trail map because that will mess up trail data
    // 3x3 blur
    float4 sum = 0;
    float blurRadius = 1;
	for (int offsetX = -blurRadius; offsetX <= blurRadius; offsetX++) {
		for (int offsetY = -blurRadius; offsetY <= blurRadius; offsetY++) {
			int sampleX = min(width-1, max(0, id.x + offsetX));
			int sampleY = min(height-1, max(0, id.y + offsetY));
			sum += TrailMapTexture[int2(sampleX,sampleY)];
		}
	}

    float diffuseRate = 0.5;
	float4 blurredColor = sum / 9;
    float4 originalColor = TrailMapTexture[id.xy];
	// float diffuseWeight = saturate(diffuseRate * deltaTime);
	// blurredColor = originalColor * (1 - diffuseWeight) + blurredColor * (diffuseWeight);
	blurredColor = originalColor * (1 - diffuseRate) + blurredColor * diffuseRate;
	// blurredColor = originalColor * (1 - 0.9) + blurredColor;

    float decayRate = 0.001;
	// DiffusedTrailMapTexture[id.xy] = blurredColor * saturate(1 - decayRate * deltaTime);
	// DiffusedTrailMapTexture[id.xy] = max(0, blurredColor - decayRate * deltaTime);
	DiffusedTrailMapTexture[id.xy] = max(0, blurredColor);
}