#pragma kernel CSPositionMap

struct Agent {
    float2 position;
    float2 direction;
};

int width;
int height;
float speed;
float deltaTime;
float numOfAgents;
float sensorAngle;
float sensorRange;

RWStructuredBuffer<Agent> AgentsBuffer;
RWTexture2D<float4> PositionTexture; // use RWTexture2D for UAV access
RWTexture2D<float4> TrailMapTexture; // use RWTexture2D for UAV access

float sense(Agent agent, float2 center, float2 newDirection)
{
    // note: add center here
    float2 lookAheadPosition = agent.position + center + sensorRange * speed * newDirection * deltaTime;
    float sum = 0;

    for (int offsetX = -1; offsetX <= 1; offsetX++) {
        for (int offsetY = -1; offsetY <= 1; offsetY++) {
			int sampleX = min(width-1, max(0, lookAheadPosition.x + offsetX));
			int sampleY = min(height-1, max(0, lookAheadPosition.y + offsetY));
			sum += TrailMapTexture[int2(sampleX,sampleY)].x;
        }
    }

    return sum;
}

[numthreads(32, 1, 1)]
void CSPositionMap(uint3 id : SV_DispatchThreadID)
{
    // note: prevents undefined behavior that draws agents at the texture map center
    if (float(id.x) >= numOfAgents) {
        return;
    }

    float2 pos = AgentsBuffer[id.x].position + speed * AgentsBuffer[id.x].direction * deltaTime;

    uint2 dimensions;
    PositionTexture.GetDimensions(dimensions.x, dimensions.y);
    float maxX = dimensions.x / 2;
    float maxY = dimensions.y / 2;

    if (pos.x < -maxX + 10 || pos.x > maxX - 10) {
        AgentsBuffer[id.x].direction.x *= -1;
        pos = AgentsBuffer[id.x].position + speed * AgentsBuffer[id.x].direction * deltaTime;
    }
    if (pos.y < -maxY + 10|| pos.y > maxY - 10) {
        AgentsBuffer[id.x].direction.y *= -1;
        pos = AgentsBuffer[id.x].position + speed * AgentsBuffer[id.x].direction * deltaTime;
    }

    AgentsBuffer[id.x].position = pos;
    float2 center = dimensions / 2;
    pos += center;
    PositionTexture[int2(pos)] = float4(1, 0, 0, 1);

    // Convert angles to radians
    float leftRadians = radians(-sensorAngle);
    float rightRadians = radians(sensorAngle);

    // Create rotation matrices
    float2x2 leftRotationMatrix = float2x2(
        cos(leftRadians), -sin(leftRadians),
        sin(leftRadians), cos(leftRadians)
    );
    float2x2 rightRotationMatrix = float2x2(
        cos(rightRadians), -sin(rightRadians),
        sin(rightRadians), cos(rightRadians)
    );

    // get left right vectors
    float2 forwardVector = AgentsBuffer[id.x].direction;
    float2 leftVector = mul(leftRotationMatrix, forwardVector);
    float2 rightVector = mul(rightRotationMatrix, forwardVector);

    Agent agent = AgentsBuffer[id.x];
    float forwardSum = sense(agent, center, forwardVector);
    float leftSum = sense(agent, center, leftVector);
    float rightSum = sense(agent, center, rightVector);

    if (forwardSum >= leftSum && forwardSum >= rightSum) {
        // do nothing
    } else if (forwardSum < leftSum && forwardSum < rightSum) {
        // do nothing

        // todo: create a better randomization function
        // todo: change colors of agents with time
        // todo: add multiple agents that do not interact with each other
        if (deltaTime % 2 == 0) {
            AgentsBuffer[id.x].direction = rightVector;
        } else {
            AgentsBuffer[id.x].direction = leftVector;
        }
    } else if (rightSum > leftSum) {
        AgentsBuffer[id.x].direction = rightVector;
    } else if (leftSum > rightSum) {
        AgentsBuffer[id.x].direction = leftVector;
    } else {
        // do nothing
    }
}

#pragma kernel CSTrailMap
float trailDecayRate;

[numthreads(8, 8, 1)]
void CSTrailMap(uint3 id : SV_DispatchThreadID)
{
    // todo: check if this is first undefined on the first run (looks like it's not)
    float4 trailMapColor = TrailMapTexture[id.xy];

    // note: doing this first seems more reasonable (kinda)
    // lower the trail map color slightly on each loop to add a "fading" effect
    trailMapColor = max(0, trailMapColor.x - trailDecayRate);

    // note: if the positionTexture is set to 1, then set trailMapColor to 1 as well
    trailMapColor = max(PositionTexture[id.xy].x, trailMapColor.x);

    TrailMapTexture[id.xy] = trailMapColor;
}


// NOTE: DO THIS IN A SEPARATE PASS
#pragma kernel CSDiffuse
RWTexture2D<float4> DiffusedTrailMapTexture;
float diffuseRate;
float diffuseDecayRate;

[numthreads(8, 8, 1)]
void CSDiffuse(uint3 id : SV_DispatchThreadID)
{
    // note: do not blur on the same map as trail map because that will mess up trail data
    // 3x3 blur
    float4 sum = 0;
    float blurRadius = 1;
	for (int offsetX = -blurRadius; offsetX <= blurRadius; offsetX++) {
		for (int offsetY = -blurRadius; offsetY <= blurRadius; offsetY++) {
			int sampleX = min(width-1, max(0, id.x + offsetX));
			int sampleY = min(height-1, max(0, id.y + offsetY));
			sum += TrailMapTexture[int2(sampleX,sampleY)];
		}
	}

	float4 blurredColor = sum / 9;
    float4 originalColor = TrailMapTexture[id.xy];
	// float diffuseWeight = saturate(diffuseRate * deltaTime);
	// blurredColor = originalColor * (1 - diffuseWeight) + blurredColor * (diffuseWeight);
	blurredColor = originalColor * (1 - diffuseRate) + blurredColor * diffuseRate;
	DiffusedTrailMapTexture[id.xy] = max(0, blurredColor);

    // note: both approaches essentially perform the same operation
	// DiffusedTrailMapTexture[id.xy] = blurredColor * saturate(1 - diffuseDecayRate * deltaTime);
	DiffusedTrailMapTexture[id.xy] = max(0, blurredColor - diffuseDecayRate * deltaTime);
    // note: expands
	// DiffusedTrailMapTexture[id.xy] = max(0, blurredColor + diffuseDecayRate * deltaTime);
}