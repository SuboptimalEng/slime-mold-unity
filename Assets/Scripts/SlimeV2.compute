#pragma kernel CSPositionMap

struct Agent {
    float2 position;
    float angleInRadians;
    int speciesIndex;
    int4 speciesMask;
};

struct SpeciesSettings {
    float sensorOffset;
    float sensorAngle;
    float rotationAngle;
    float4 color;
};

int width;
int height;
float speed;
float distFromMapEdge;

float time;
float deltaTime;

float numOfAgents;
// float numOfSpecies;

RWStructuredBuffer<Agent> AgentsBuffer;
RWStructuredBuffer<SpeciesSettings> SpeciesSettingsBuffer;

RWTexture2D<float4> PositionTexture; // use RWTexture2D for UAV access
RWTexture2D<float4> TrailMapTexture; // use RWTexture2D for UAV access

float2 radiansToDirection(float angleInRadians) {
    float2 direction;
    direction.x = cos(angleInRadians);
    direction.y = sin(angleInRadians);
    return direction;
}

float sense(Agent agent, float2 center, float2 newDirection) {
    // float2 sensorPosition = agent.position + center + sensorOffset * newDirection;
    float2 sensorPosition =
        agent.position + center + SpeciesSettingsBuffer[agent.speciesIndex].sensorOffset * newDirection;
    // float2 sensorPosition =
    //     agent.position + center + 20 * newDirection;

    float sum = 0;

    // int4 senseWeight = agent.speciesMask * 2 - 1;
    // int4 senseWeight = agent.speciesMask;

    for (int offsetX = -1; offsetX <= 1; offsetX++) {
        for (int offsetY = -1; offsetY <= 1; offsetY++) {
			int sampleX = min(width-1, max(0, sensorPosition.x + offsetX));
			int sampleY = min(height-1, max(0, sensorPosition.y + offsetY));

            int i = agent.speciesIndex;
            if (i == 0) {
                sum += TrailMapTexture[int2(sampleX,sampleY)].x;
                // avoidance
                sum -= TrailMapTexture[int2(sampleX,sampleY)].y;
            } else {
                sum += TrailMapTexture[int2(sampleX,sampleY)].y;
                // avoidance
                sum -= TrailMapTexture[int2(sampleX,sampleY)].x;
            }

            // for (int i = 0; i < 2; i++) {
            //     sum += dot(TrailMapTexture[int2(sampleX,sampleY)], senseWeight);
            // }

            // todo: update the sum correctly
            // sum += TrailMapTexture[int2(sampleX,sampleY)].x;
        }
    }

    return sum;
}

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

[numthreads(32, 1, 1)]
void CSPositionMap(uint3 id : SV_DispatchThreadID) {
    // note: prevents undefined behavior that draws agents at the texture map center
    if (float(id.x) >= numOfAgents) {
        return;
    }

    Agent agent = AgentsBuffer[id.x];
    float2 agentPosition = agent.position;
    float2 agentDirection = radiansToDirection(agent.angleInRadians);
    int4 agentSpeciesMask = agent.speciesMask;

    float2 pos = agentPosition + speed * agentDirection * deltaTime;

    uint2 dimensions;
    PositionTexture.GetDimensions(dimensions.x, dimensions.y);
    float maxX = dimensions.x / 2;
    float maxY = dimensions.y / 2;

    if (pos.x < -maxX + distFromMapEdge || pos.x > maxX - distFromMapEdge) {
        agentDirection.x *= -1;
        AgentsBuffer[id.x].angleInRadians = atan2(agentDirection.y, agentDirection.x);
        pos = agentPosition + speed * agentDirection * deltaTime;
    }

    if (pos.y < -maxY + distFromMapEdge || pos.y > maxY - distFromMapEdge) {
        agentDirection.y *= -1;
        AgentsBuffer[id.x].angleInRadians = atan2(agentDirection.y, agentDirection.x);
        pos = agentPosition + speed * agentDirection * deltaTime;
    }

    AgentsBuffer[id.x].position = pos;
    float2 center = dimensions / 2;
    pos += center;
    PositionTexture[int2(pos)] = max(PositionTexture[int2(pos)], agentSpeciesMask);
    // note: this approach is incorrectly overwriting the data of agents
    // PositionTexture[int2(pos)] = agentSpeciesMask;


    // // todo: work on sensing functions
    float forwardRadians = agent.angleInRadians;

    float sensorAngle = SpeciesSettingsBuffer[agent.speciesIndex].sensorAngle;
    float leftRadians = agent.angleInRadians + radians(sensorAngle);
    float rightRadians = agent.angleInRadians - radians(sensorAngle);

    float2 forwardDirection = radiansToDirection(forwardRadians);
    float2 leftDirection = radiansToDirection(leftRadians);
    float2 rightDirection = radiansToDirection(rightRadians);

    float forwardSum = sense(agent, center, forwardDirection);
    float leftSum = sense(agent, center, leftDirection);
    float rightSum = sense(agent, center, rightDirection);

    // note: random fn -> https://github.com/SebLague/Slime-Simulation
    uint random = hash(pos.y * width + pos.x + hash(id.x + time * 100000));
    float randomSteerStrength = scaleToRange01(random);
    float rotationAngle = SpeciesSettingsBuffer[agent.speciesIndex].rotationAngle;

    if (forwardSum >= leftSum && forwardSum >= rightSum) {
        // do nothing
    } else if (forwardSum < leftSum && forwardSum < rightSum) {
        AgentsBuffer[id.x].angleInRadians +=
            (randomSteerStrength - 0.5) * 2 * (rotationAngle) * deltaTime;
    } else if (leftSum > rightSum) {
        AgentsBuffer[id.x].angleInRadians +=
            randomSteerStrength * (rotationAngle) * deltaTime;
    } else if (rightSum > leftSum) {
        AgentsBuffer[id.x].angleInRadians -=
            randomSteerStrength * (rotationAngle) * deltaTime;
    } else {
        // do nothing
    }
}

#pragma kernel CSTrailMap

float trailDecayRate;

[numthreads(8, 8, 1)]
void CSTrailMap(uint3 id : SV_DispatchThreadID) {
    // todo: check if this is first undefined on the first run (looks like it's not)
    float4 trailMapColor = TrailMapTexture[id.xy];

    // note: old approach, doing this first seems more reasonable (kinda)
    // lower the trail map color slightly on each loop to add a "fading" effect
    // trailMapColor = max(0, trailMapColor - trailDecayRate * deltaTime);
    // note: if the positionTexture is set to 1, then set trailMapColor to 1 as well
    // trailMapColor = max(PositionTexture[id.xy].x, trailMapColor.x);

    // note: new approach
    trailMapColor = max(0, trailMapColor - trailDecayRate * deltaTime);
    trailMapColor = max(
        trailMapColor,
        PositionTexture[id.xy]
    );

    TrailMapTexture[id.xy] = trailMapColor;
}


// // NOTE: DO THIS IN A SEPARATE PASS
#pragma kernel CSDiffuseMap
float diffuseRate;
float diffuseDecayRate;
RWTexture2D<float4> DiffuseMapTexture;
RWTexture2D<float4> ColorMapTexture;
// note: example sampling from a texture map!!!
Texture2D<float4> GradientTexture;
// note: this is required? not sure exactly how it works
SamplerState samplerGradientTexture;
[numthreads(8, 8, 1)]
void CSDiffuseMap(uint3 id : SV_DispatchThreadID) {
    // note: do not blur on the same map as trail map because that will mess up trail data
    // 3x3 blur
    float4 sum = 0;
    float blurRadius = 1;
	for (int offsetX = -blurRadius; offsetX <= blurRadius; offsetX++) {
		for (int offsetY = -blurRadius; offsetY <= blurRadius; offsetY++) {
			int sampleX = min(width-1, max(0, id.x + offsetX));
			int sampleY = min(height-1, max(0, id.y + offsetY));
			sum += TrailMapTexture[int2(sampleX,sampleY)];
		}
	}
	float4 blurredColor = sum / 9;
    float4 originalColor = TrailMapTexture[id.xy];
	// float diffuseWeight = saturate(diffuseRate * deltaTime);
	// blurredColor = originalColor * (1 - diffuseWeight) + blurredColor * (diffuseWeight);
	blurredColor = originalColor * (1 - diffuseRate) + blurredColor * diffuseRate;
	DiffuseMapTexture[id.xy] = max(0, blurredColor);
    // note: the first approach does not fully clear out blurred colors
    // note: the second approach fully clears out blurred colors in due time
	// DiffuseMapTexture[id.xy] = blurredColor * saturate(1 - diffuseDecayRate * deltaTime);
	DiffuseMapTexture[id.xy] = max(0, blurredColor - diffuseDecayRate * deltaTime);
    // // note: set the color map here
    // // we know that x, y, z values are all the same so we can sample from any one of them
    // float t = DiffuseMapTexture[id.xy].x;
    // // texture map is 2d but y value is only 1 in height, so we only care about x coord
    // float2 textureCoord = float2(max(0.01,t), 0);
    // // note: not sure why the third method works, but it works
    // // todo: maybe figure out why it works
    // // float4 color = tex2D(samplerGradientTexture, uv); // dx9
    // // float4 color = GradientTexture.Sample(samplerGradientTexture, uv); // dx11
    // float4 color = GradientTexture.SampleLevel(samplerGradientTexture, textureCoord, 0); // dx11
    // ColorMapTexture[id.xy] = color;
    // note: new approach

    float4 finalColor = 0;
    for (int i = 0; i < 2; i++) {
        float4 mask = float4(i == 0, i == 1, 0, 1);
        finalColor = finalColor + SpeciesSettingsBuffer[i].color * dot(originalColor, mask);
    }
    ColorMapTexture[id.xy] = finalColor;
}